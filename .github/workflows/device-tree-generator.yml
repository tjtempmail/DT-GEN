name: ðŸ“± AOSP Device Tree Generator Pro

on:
  workflow_dispatch:
    inputs:
      rom_url:
        description: 'ðŸ”— Direct link to stock ROM (ZIP with images, payload.bin, or super.img)'
        required: true
        type: string
      rom_type:
        description: 'ðŸ“¦ ROM Format'
        required: true
        type: choice
        options:
          - 'auto-detect'
          - 'payload.bin (A/B OTA)'
          - 'super.img (Dynamic partitions)'
          - 'sparse_images (system.img/vendor.img)'
          - 'scatter_flashable (MTK/SP Flash Tool)'
          - 'br (Brotli compressed)'
        default: 'auto-detect'
      device_codename:
        description: 'ðŸ·ï¸ Device Codename (optional, auto-detected)'
        required: false
        type: string
      brand:
        description: 'ðŸ¢ Brand (optional, auto-detected)'
        required: false
        type: string
      generate_proprietary:
        description: 'ðŸ” Generate proprietary-files.txt'
        required: true
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  WORKSPACE: ${{ github.workspace }}
  OUTPUT_DIR: ${{ github.workspace }}/device_tree_output

jobs:
  generate-device-tree:
    runs-on: ubuntu-22.04
    timeout-minutes: 150
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ðŸ› ï¸ Install Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            aria2 p7zip-full p7zip-rar unrar unzip zip \
            cpio file liblz4-tool brotli simg2img img2simg \
            android-sdk-libsparse-utils erofs-utils f2fs-tools \
            git curl wget bc xz-utils lzma gzip \
            libxml2-utils python3-pip e2fsprogs mount \
            util-linux

      - name: ðŸ”§ Install Android Tools & Python Packages
        run: |
          # Install SDK
          mkdir -p $HOME/android-sdk/cmdline-tools
          cd $HOME/android-sdk/cmdline-tools
          curl -sS https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -o cmdline-tools.zip
          unzip -q cmdline-tools.zip && mv cmdline-tools latest
          echo "$HOME/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "$HOME/android-sdk/platform-tools" >> $GITHUB_PATH
          yes | sdkmanager --licenses > /dev/null 2>&1 || true
          sdkmanager "platform-tools" > /dev/null 2>&1 || true
          
          # Install Python tools
          python -m pip install --upgrade pip
          pip install aospdtgen dumpyara pyaxmlparser protobuf

      # ============================================================================
      # STEP 1: Download ROM
      # ============================================================================
      - name: â¬‡ï¸ Download ROM
        id: download
        run: |
          ROM_URL="${{ github.event.inputs.rom_url }}"
          ROM_FILENAME=$(basename "$ROM_URL" | sed 's/[?#].*$//' | sed 's/[^a-zA-Z0-9._-]/_/g')
          [[ "$ROM_FILENAME" =~ \.(zip|tar|md5|lz4|br|img|bin)$ ]] || ROM_FILENAME="rom.zip"
          
          echo "ðŸ“¥ Downloading: $ROM_FILENAME"
          mkdir -p $WORKSPACE/rom_download && cd $WORKSPACE/rom_download
          
          # Try multiple download methods
          if ! aria2c --max-connection-per-server=16 --split=16 --min-split-size=1M \
               --max-tries=3 --timeout=600 --file-allocation=none \
               --user-agent="Mozilla/5.0" -o "$ROM_FILENAME" "$ROM_URL" 2>/dev/null; then
            echo "âš ï¸ aria2c failed, trying wget..."
            wget --tries=3 --timeout=600 --user-agent="Mozilla/5.0" -O "$ROM_FILENAME" "$ROM_URL" || \
            curl -L --max-time 600 -A "Mozilla/5.0" -o "$ROM_FILENAME" "$ROM_URL"
          fi
          
          # Validate
          if [ ! -f "$ROM_FILENAME" ]; then
            echo "âŒ Download failed!"; exit 1
          fi
          
          FILE_SIZE=$(stat -c%s "$ROM_FILENAME" 2>/dev/null || stat -f%z "$ROM_FILENAME")
          echo "ðŸ“Š Size: $FILE_SIZE bytes ($(numfmt --to=iec-i $FILE_SIZE))"
          
          # Check if file is too small (HTML error page)
          if [ "$FILE_SIZE" -lt 100000 ]; then
            echo "âš ï¸ File too small! Content:"
            head -c 1000 "$ROM_FILENAME"
            echo ""; echo "âŒ Invalid download (likely HTML page)"; exit 1
          fi
          
          # Detect file type
          FILE_TYPE=$(file -b "$ROM_FILENAME")
          echo "ðŸ“‹ Type: $FILE_TYPE"
          
          echo "rom_path=$WORKSPACE/rom_download/$ROM_FILENAME" >> $GITHUB_OUTPUT
          echo "rom_size=$FILE_SIZE" >> $GITHUB_OUTPUT
          echo "file_type=$FILE_TYPE" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 2: Smart Extraction (Multi-Format Support)
      # ============================================================================
      - name: ðŸ”“ Smart Extraction
        id: extract
        run: |
          ROM_PATH="${{ steps.download.outputs.rom_path }}"
          EXTRACT_DIR="$WORKSPACE/rom_extracted"
          mkdir -p "$EXTRACT_DIR"
          
          echo "ðŸ”“ Extracting: $(basename "$ROM_PATH")"
          cd "$WORKSPACE/rom_download"
          
          # First, try to extract as archive if it's a zip/tar
          if [[ "$ROM_PATH" == *.zip ]]; then
            echo "ðŸ“¦ Extracting ZIP contents..."
            unzip -q "$ROM_PATH" -d "$EXTRACT_DIR" 2>/dev/null || true
            
            # Check if we got payload.bin (A/B OTA)
            if [ -f "$EXTRACT_DIR/payload.bin" ]; then
              echo "âœ… Found payload.bin (A/B OTA format)"
              ROM_TYPE="payload"
            # Check for super.img
            elif [ -f "$EXTRACT_DIR/super.img" ] || [ -f "$EXTRACT_DIR/Super.img" ]; then
              echo "âœ… Found super.img (Dynamic partitions)"
              ROM_TYPE="super"
            # Check for sparse images (system.img, vendor.img)
            elif ls "$EXTRACT_DIR"/*.img 2>/dev/null | grep -qE "(system|vendor|boot)"; then
              echo "âœ… Found .img files (Sparse images)"
              ROM_TYPE="sparse"
            # Check for scatter file (MTK/SP Flash Tool)
            elif ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | head -1 | grep -q scatter; then
              echo "âœ… Found scatter file (MTK/SP Flash Tool format)"
              ROM_TYPE="scatter"
            else
              echo "ðŸ” Searching deeper in archive..."
              # Try nested extraction
              find "$EXTRACT_DIR" -name "*.zip" -exec unzip -q {} -d "$EXTRACT_DIR" \; 2>/dev/null || true
            fi
          elif [[ "$ROM_PATH" == *.tar* ]] || [[ "$ROM_PATH" == *.tgz ]]; then
            echo "ðŸ“¦ Extracting TAR archive..."
            tar -xf "$ROM_PATH" -C "$EXTRACT_DIR" 2>/dev/null || true
          fi
          
          # Handle specific formats
          case "${{ github.event.inputs.rom_type }}" in
            "payload.bin"*)
              ROM_TYPE="payload"
              ;;
            "super.img"*)
              ROM_TYPE="super"
              ;;
            "sparse_images"*)
              ROM_TYPE="sparse"
              ;;
            "scatter_flashable"*)
              ROM_TYPE="scatter"
              ;;
          esac
          
          # Process based on detected type
          if [ "$ROM_TYPE" == "payload" ] || [ -f "$EXTRACT_DIR/payload.bin" ]; then
            echo "ðŸ”§ Processing payload.bin..."
            # Install payload dumper if needed
            pip install protobuf 2>/dev/null || true
            git clone --depth 1 https://github.com/vm03/payload_dumper.git /tmp/payload_dumper 2>/dev/null || true
            cd /tmp/payload_dumper && python payload_dumper.py "$EXTRACT_DIR/payload.bin" --out "$EXTRACT_DIR" 2>/dev/null || \
            python3 -c "
import sys
sys.path.insert(0, '/tmp/payload_dumper')
from payload_dumper import main
import argparse
args = argparse.Namespace()
args.payload = '$EXTRACT_DIR/payload.bin'
args.out = '$EXTRACT_DIR'
args.diff = None
args.old = None
args.partitions = ['system', 'vendor', 'product', 'system_ext', 'odm']
main(args)
" 2>/dev/null || echo "âš ï¸ Payload extraction may have failed"
            cd "$WORKSPACE"
            
          elif [ "$ROM_TYPE" == "super" ] || ls "$EXTRACT_DIR"/[Ss]uper.img 2>/dev/null | grep -q .; then
            echo "ðŸ”§ Processing super.img (Dynamic partitions)..."
            SUPER_IMG=$(ls "$EXTRACT_DIR"/[Ss]uper.img 2>/dev/null | head -1)
            
            # Install unsuper for fast extraction
            pip install unsuper numpy 2>/dev/null || true
            
            # Try unsuper first (fastest)
            if command -v unsuper &> /dev/null; then
              echo "Using unsuper for extraction..."
              unsuper "$SUPER_IMG" "$EXTRACT_DIR" --jobs 4 2>/dev/null || true
            else
              # Fallback: manual lpunpack if available
              if command -v lpunpack &> /dev/null; then
                echo "Using lpunpack..."
                lpunpack "$SUPER_IMG" "$EXTRACT_DIR" 2>/dev/null || true
              else
                # Last resort: simg2img + manual extraction attempt
                echo "Converting sparse super.img..."
                simg2img "$SUPER_IMG" "$EXTRACT_DIR/super.raw.img" 2>/dev/null || true
              fi
            fi
            
          elif [ "$ROM_TYPE" == "scatter" ] || ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | head -1 | grep -q scatter; then
            echo "ðŸ”§ Processing MTK Scatter ROM..."
            SCATTER_FILE=$(ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | head -1)
            echo "Scatter file: $SCATTER_FILE"
            
            # MTK ROMs often have sparse chunks that need to be combined
            # Look for system_sparse_chunk files
            if ls "$EXTRACT_DIR"/system_sparse_chunk* 2>/dev/null | grep -q .; then
              echo "ðŸ“¦ Combining sparse chunks into system.img..."
              cat "$EXTRACT_DIR"/system_sparse_chunk* > "$EXTRACT_DIR/system.img" 2>/dev/null || true
            fi
            
            # Convert any sparse .img files to raw
            for img in "$EXTRACT_DIR"/*.img; do
              if [ -f "$img" ]; then
                echo "Converting sparse image: $(basename "$img")"
                simg2img "$img" "${img%.img}.raw.img" 2>/dev/null || true
              fi
            done
          fi
          
          # Convert any remaining sparse images to raw
          echo "ðŸ”„ Converting sparse images..."
          for sparse in "$EXTRACT_DIR"/*.img "$EXTRACT_DIR"/*/*.img 2>/dev/null; do
            if [ -f "$sparse" ]; then
              # Check if it's a sparse image
              if file "$sparse" | grep -q "sparse"; then
                echo "Converting: $(basename "$sparse")"
                simg2img "$sparse" "${sparse%.img}.raw.img" 2>/dev/null || true
              fi
            fi
          done
          
          # Mount raw images to extract contents
          echo "ðŸ“‚ Setting up mount points..."
          mkdir -p "$EXTRACT_DIR/mounted"
          
          for raw_img in "$EXTRACT_DIR"/*.raw.img "$EXTRACT_DIR"/*/*.raw.img 2>/dev/null; do
            if [ -f "$raw_img" ]; then
              partition_name=$(basename "$raw_img" .raw.img)
              mount_point="$EXTRACT_DIR/$partition_name"
              
              echo "Mounting $partition_name..."
              mkdir -p "$mount_point"
              
              # Try to mount as ext4
              if sudo mount -o loop,ro -t ext4 "$raw_img" "$mount_point" 2>/dev/null; then
                echo "âœ… Mounted $partition_name as ext4"
              elif sudo mount -o loop,ro -t auto "$raw_img" "$mount_point" 2>/dev/null; then
                echo "âœ… Mounted $partition_name (auto-detected)"
              else
                echo "âš ï¸ Could not mount $partition_name"
                rmdir "$mount_point" 2>/dev/null || true
              fi
            fi
          done
          
          # List what we have
          echo "ðŸ“ Final extraction structure:"
          find "$EXTRACT_DIR" -maxdepth 2 -type d 2>/dev/null | head -30 || true
          
          # Check for system partition (required by aospdtgen)
          SYSTEM_FOUND=false
          if [ -d "$EXTRACT_DIR/system" ] || [ -d "$EXTRACT_DIR/system_ext" ]; then
            SYSTEM_FOUND=true
            DUMP_DIR="$EXTRACT_DIR"
          elif [ -d "$EXTRACT_DIR/mounted/system" ]; then
            SYSTEM_FOUND=true
            DUMP_DIR="$EXTRACT_DIR/mounted"
          else
            # Search for any directory with build.prop
            BUILD_PROP_DIR=$(find "$EXTRACT_DIR" -name "build.prop" -type f -exec dirname {} \; 2>/dev/null | head -1)
            if [ -n "$BUILD_PROP_DIR" ]; then
              SYSTEM_FOUND=true
              DUMP_DIR=$(dirname "$BUILD_PROP_DIR")
              echo "Found system at: $DUMP_DIR"
            fi
          fi
          
          if [ "$SYSTEM_FOUND" != "true" ]; then
            echo "âŒ ERROR: No system partition found!"
            echo "Available files:"
            find "$EXTRACT_DIR" -type f 2>/dev/null | head -20 || true
            exit 1
          fi
          
          echo "âœ… Extraction complete. Dump path: $DUMP_DIR"
          echo "dump_path=$DUMP_DIR" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 3: Generate Device Tree
      # ============================================================================
      - name: ðŸŒ³ Generate Device Tree
        id: generate
        run: |
          DUMP_PATH="${{ steps.extract.outputs.dump_path }}"
          OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
          
          echo "ðŸ” Pre-generation check..."
          if [ ! -d "$DUMP_PATH" ]; then
            echo "âŒ Dump path missing: $DUMP_PATH"; exit 1
          fi
          
          # Verify system partition exists
          if [ ! -d "$DUMP_PATH/system" ] && [ ! -d "$DUMP_PATH/system_ext" ] && [ ! -f "$DUMP_PATH/system/build.prop" ]; then
            echo "âŒ System partition not found in dump!"
            echo "Contents:"
            ls -la "$DUMP_PATH" || true
            exit 1
          fi
          
          mkdir -p "$OUTPUT_DIR"
          
          echo "ðŸŒ³ Running aospdtgen..."
          echo "Input: $DUMP_PATH"
          echo "Output: $OUTPUT_DIR"
          
          AOSP_ARGS="-o \"$OUTPUT_DIR\""
          [[ "${{ github.event.inputs.generate_proprietary }}" == "false" ]] && AOSP_ARGS="$AOSP_ARGS --no-proprietary-files"
          
          if ! timeout 600 python -m aospdtgen $AOSP_ARGS "$DUMP_PATH" 2>&1 | tee aospdtgen.log; then
            echo "âš ï¸ aospdtgen completed with warnings"
          fi
          
          # Verify output
          if [ ! -d "$OUTPUT_DIR" ] || [ -z "$(ls -A "$OUTPUT_DIR" 2>/dev/null)" ]; then
            echo "âŒ No device tree generated!"
            exit 1
          fi
          
          echo "âœ… Device tree generated!"
          echo "Files: $(find "$OUTPUT_DIR" -type f | wc -l)"
          echo "output_path=$OUTPUT_DIR" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 4: Package & Upload
      # ============================================================================
      - name: ðŸ“¦ Package & Upload
        uses: actions/upload-artifact@v4
        with:
          name: device-tree-${{ github.run_id }}
          path: ${{ env.OUTPUT_DIR }}/*
          retention-days: 30

      - name: ðŸ“‹ Summary
        if: always()
        run: |
          echo "## ðŸ“± Device Tree Generation" >> $GITHUB_STEP_SUMMARY
          echo "Status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY
          echo "ROM: ${{ github.event.inputs.rom_url }}" >> $GITHUB_STEP_SUMMARY
