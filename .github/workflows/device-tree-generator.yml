name: ðŸ“± AOSP Device Tree Generator Pro

on:
  workflow_dispatch:
    inputs:
      rom_url:
        description: 'ðŸ”— Direct link to stock ROM (GitHub Releases, Pixeldrain, Gofile - NOT MediaFire)'
        required: true
        type: string
      rom_type:
        description: 'ðŸ“¦ ROM Format'
        required: true
        type: choice
        options:
          - 'auto-detect'
          - 'payload.bin (A/B OTA)'
          - 'super.img (Dynamic partitions)'
          - 'sparse_images (system.img/vendor.img)'
          - 'scatter_flashable (MTK/SP Flash Tool)'
        default: 'auto-detect'
      device_codename:
        description: 'ðŸ·ï¸ Device Codename (optional)'
        required: false
        type: string
      brand:
        description: 'ðŸ¢ Brand (optional)'
        required: false
        type: string
      generate_proprietary:
        description: 'ðŸ” Generate proprietary-files.txt'
        required: true
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  WORKSPACE: ${{ github.workspace }}
  OUTPUT_DIR: ${{ github.workspace }}/device_tree_output

jobs:
  generate-device-tree:
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    
    steps:
      - name: ðŸ“¥ Checkout
        uses: actions/checkout@v4

      - name: ðŸ Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ðŸ› ï¸ Install Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            aria2 p7zip-full p7zip-rar unrar unzip zip \
            cpio file liblz4-tool brotli simg2img img2simg \
            android-sdk-libsparse-utils erofs-utils f2fs-tools \
            git curl wget bc xz-utils lzma gzip \
            libxml2-utils python3-pip e2fsprogs mount \
            util-linux kmod

      - name: ðŸ”§ Install Android SDK & Tools
        run: |
          mkdir -p $HOME/android-sdk/cmdline-tools
          cd $HOME/android-sdk/cmdline-tools
          curl -sS https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -o cmdline-tools.zip
          unzip -q cmdline-tools.zip && mv cmdline-tools latest
          echo "$HOME/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "$HOME/android-sdk/platform-tools" >> $GITHUB_PATH
          yes | sdkmanager --licenses > /dev/null 2>&1 || true
          sdkmanager "platform-tools" > /dev/null 2>&1 || true
          
          python -m pip install --upgrade pip
          pip install aospdtgen dumpyara pyaxmlparser protobuf numpy 2>/dev/null || true
          
          # Install payload dumper
          git clone --depth 1 https://github.com/vm03/payload_dumper.git /tmp/payload_dumper 2>/dev/null || true

      - name: â¬‡ï¸ Download ROM
        id: download
        run: |
          ROM_URL="${{ github.event.inputs.rom_url }}"
          ROM_FILENAME=$(basename "$ROM_URL" | sed 's/[?#].*$//' | sed 's/[^a-zA-Z0-9._-]/_/g')
          [[ "$ROM_FILENAME" =~ \.(zip|tar|md5|lz4|br|img|bin|tgz)$ ]] || ROM_FILENAME="rom.zip"
          
          echo "ðŸ“¥ Downloading: $ROM_FILENAME"
          mkdir -p $WORKSPACE/rom_download && cd $WORKSPACE/rom_download
          
          # Try aria2c
          if ! aria2c --max-connection-per-server=16 --split=16 --min-split-size=1M \
               --max-tries=5 --timeout=600 --file-allocation=none \
               --user-agent="Mozilla/5.0" --allow-overwrite=true \
               -o "$ROM_FILENAME" "$ROM_URL" 2>/dev/null; then
            echo "âš ï¸ aria2c failed, trying wget..."
            wget --tries=5 --timeout=600 --user-agent="Mozilla/5.0" -O "$ROM_FILENAME" "$ROM_URL" || \
            curl -L --max-time 600 -A "Mozilla/5.0" -o "$ROM_FILENAME" "$ROM_URL"
          fi
          
          # Validate
          if [ ! -f "$ROM_FILENAME" ]; then
            echo "âŒ Download failed!"; exit 1
          fi
          
          FILE_SIZE=$(stat -c%s "$ROM_FILENAME" 2>/dev/null || stat -f%z "$ROM_FILENAME")
          echo "ðŸ“Š Size: $FILE_SIZE bytes ($(numfmt --to=iec-i $FILE_SIZE))"
          
          # Check if too small
          if [ "$FILE_SIZE" -lt 1000000 ]; then
            echo "âŒ File too small! Likely HTML error page."
            head -c 1000 "$ROM_FILENAME"
            exit 1
          fi
          
          FILE_TYPE=$(file -b "$ROM_FILENAME")
          echo "ðŸ“‹ Type: $FILE_TYPE"
          
          # Check if HTML
          if [[ "$FILE_TYPE" == *"HTML"* ]]; then
            echo "âŒ Downloaded HTML instead of ROM!"
            exit 1
          fi
          
          echo "rom_path=$WORKSPACE/rom_download/$ROM_FILENAME" >> $GITHUB_OUTPUT
          echo "rom_size=$FILE_SIZE" >> $GITHUB_OUTPUT

      - name: ðŸ”“ Smart Extraction
        id: extract
        run: |
          ROM_PATH="${{ steps.download.outputs.rom_path }}"
          EXTRACT_DIR="$WORKSPACE/rom_extracted"
          WORK_DIR="$WORKSPACE/work_dir"
          
          mkdir -p "$EXTRACT_DIR" "$WORK_DIR"
          
          echo "ðŸ”“ Extracting: $(basename "$ROM_PATH")"
          cd "$WORKSPACE/rom_download"
          
          ROM_TYPE="${{ github.event.inputs.rom_type }}"
          
          # Extract if archive
          if [[ "$ROM_PATH" == *.zip ]] || file -b "$ROM_PATH" | grep -q "Zip"; then
            echo "ðŸ“¦ Extracting ZIP..."
            unzip -o -q "$ROM_PATH" -d "$EXTRACT_DIR" 2>/dev/null || \
            7z x "$ROM_PATH" -o"$EXTRACT_DIR" -y > /dev/null 2>&1 || true
            
            # Auto-detect if needed
            if [[ "$ROM_TYPE" == "auto-detect" ]]; then
              if [ -f "$EXTRACT_DIR/payload.bin" ]; then
                ROM_TYPE="payload"
              elif ls "$EXTRACT_DIR"/[Ss]uper.img 2>/dev/null | grep -q .; then
                ROM_TYPE="super"
              elif ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | grep -q scatter; then
                ROM_TYPE="scatter"
              elif ls "$EXTRACT_DIR"/*.img 2>/dev/null | grep -qE "(system|vendor)"; then
                ROM_TYPE="sparse"
              fi
            fi
          fi
          
          echo "ðŸ”§ Processing type: $ROM_TYPE"
          
          case "$ROM_TYPE" in
            payload*)
              if [ -f "$EXTRACT_DIR/payload.bin" ]; then
                echo "ðŸ”§ Extracting payload.bin..."
                cd /tmp/payload_dumper
                python3 payload_dumper.py "$EXTRACT_DIR/payload.bin" --out "$WORK_DIR" 2>&1 | head -50 || \
                python3 -c "
import sys
sys.path.insert(0, '/tmp/payload_dumper')
from payload_dumper import main
import argparse
args = argparse.Namespace()
args.payload = '$EXTRACT_DIR/payload.bin'
args.out = '$WORK_DIR'
args.diff = None
args.old = None
args.partitions = ['system', 'vendor', 'product', 'system_ext', 'odm']
main(args)
" 2>/dev/null || echo "âš ï¸ Payload extraction may have issues"
                cd "$WORKSPACE"
              fi
              ;;
              
            super*)
              echo "ðŸ”§ Processing super.img..."
              SUPER_IMG=$(ls "$EXTRACT_DIR"/[Ss]uper.img 2>/dev/null | head -1)
              
              if [ -n "$SUPER_IMG" ]; then
                echo "   Found: $(basename "$SUPER_IMG")"
                
                # Install numpy first (required by unsuper)
                echo "   Installing numpy..."
                pip install numpy 2>/dev/null || pip3 install numpy || true
                
                # Try unsuper
                echo "   Trying unsuper..."
                pip install unsuper 2>/dev/null || true
                
                if command -v unsuper &> /dev/null; then
                  unsuper "$SUPER_IMG" "$WORK_DIR" 2>&1 && echo "   âœ… unsuper success" || {
                    echo "   âš ï¸ unsuper failed, using fallback..."
                  }
                fi
                
                # Check if unsuper produced anything
                if [ -z "$(ls -A "$WORK_DIR" 2>/dev/null)" ]; then
                  echo "   ðŸ”§ Fallback: Manual super extraction..."
                  
                  # Convert sparse super to raw
                  simg2img "$SUPER_IMG" "$WORK_DIR/super.raw.img" 2>/dev/null || \
                  cp "$SUPER_IMG" "$WORK_DIR/super.raw.img"
                  
                  # Try to extract with 7z (some super.img are 7z archives)
                  if command -v 7z &> /dev/null; then
                    echo "   Trying 7z extraction..."
                    7z x "$WORK_DIR/super.raw.img" -o"$WORK_DIR/7z_out" -y > /dev/null 2>&1 || true
                    
                    # Move extracted imgs to work dir
                    find "$WORK_DIR/7z_out" -name "*.img" -exec mv {} "$WORK_DIR/" \; 2>/dev/null || true
                  fi
                fi
              fi
              ;;
              
            scatter*)
              echo "ðŸ”§ Processing MTK Scatter..."
              # Combine sparse chunks
              if ls "$EXTRACT_DIR"/system_sparse_chunk* 2>/dev/null | grep -q .; then
                echo "   Combining system chunks..."
                cat "$EXTRACT_DIR"/system_sparse_chunk* > "$WORK_DIR/system.img" 2>/dev/null || true
              fi
              if ls "$EXTRACT_DIR"/vendor_sparse_chunk* 2>/dev/null | grep -q .; then
                echo "   Combining vendor chunks..."
                cat "$EXTRACT_DIR"/vendor_sparse_chunk* > "$WORK_DIR/vendor.img" 2>/dev/null || true
              fi
              # Copy any existing imgs
              find "$EXTRACT_DIR" -name "*.img" -exec cp {} "$WORK_DIR/" \; 2>/dev/null || true
              ;;
              
            sparse*)
              echo "ðŸ”§ Processing sparse images..."
              find "$EXTRACT_DIR" -name "*.img" -exec cp {} "$WORK_DIR/" \; 2>/dev/null || true
              ;;
          esac
          
          echo "ðŸ”„ Converting sparse to raw..."
          cd "$WORK_DIR"
          
          for img in *.img; do
            if [ -f "$img" ]; then
              if file "$img" | grep -q "sparse"; then
                echo "   Converting: $img"
                simg2img "$img" "${img%.img}.raw.img" 2>/dev/null && rm -f "$img" || \
                mv "$img" "${img%.img}.raw.img" 2>/dev/null || true
              else
                mv "$img" "${img%.img}.raw.img" 2>/dev/null || true
              fi
            fi
          done
          
          echo "ðŸ“‚ Mounting partitions..."
          mkdir -p "$WORKSPACE/mounted_partitions"
          
          for raw_img in *.raw.img; do
            if [ -f "$raw_img" ]; then
              part_name=$(basename "$raw_img" .raw.img)
              mount_point="$WORKSPACE/mounted_partitions/$part_name"
              
              echo "   Mounting: $part_name"
              mkdir -p "$mount_point"
              
              if sudo mount -o loop,ro -t ext4 "$raw_img" "$mount_point" 2>/dev/null || \
                 sudo mount -o loop,ro -t auto "$raw_img" "$mount_point" 2>/dev/null; then
                echo "     âœ… Mounted"
                
                # Copy contents
                dest_dir="$WORKSPACE/dump/$part_name"
                mkdir -p "$dest_dir"
                sudo cp -a "$mount_point/." "$dest_dir/" 2>/dev/null || true
                sudo umount "$mount_point" 2>/dev/null || true
              else
                echo "     âš ï¸ Could not mount"
                rmdir "$mount_point" 2>/dev/null || true
              fi
            fi
          done
          
          # Find system partition
          echo "ðŸ” Finding system..."
          if [ -d "$WORKSPACE/dump/system" ]; then
            DUMP_PATH="$WORKSPACE/dump"
          elif [ -d "$WORKSPACE/dump/system_ext" ]; then
            DUMP_PATH="$WORKSPACE/dump"
          else
            BUILD_PROP=$(find "$WORKSPACE/dump" -name "build.prop" -type f 2>/dev/null | head -1)
            if [ -n "$BUILD_PROP" ]; then
              DUMP_PATH=$(dirname "$(dirname "$BUILD_PROP")")
            else
              echo "âŒ No system found!"
              find "$WORKSPACE" -type d 2>/dev/null | head -20 || true
              exit 1
            fi
          fi
          
          echo "âœ… Dump path: $DUMP_PATH"
          echo "dump_path=$DUMP_PATH" >> $GITHUB_OUTPUT

      - name: ðŸŒ³ Generate Device Tree
        id: generate
        run: |
          DUMP_PATH="${{ steps.extract.outputs.dump_path }}"
          OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
          
          if [ ! -d "$DUMP_PATH/system" ] && [ ! -d "$DUMP_PATH/system_ext" ]; then
            echo "âŒ No system partition!"
            exit 1
          fi
          
          mkdir -p "$OUTPUT_DIR"
          
          echo "ðŸŒ³ Running aospdtgen..."
          AOSP_ARGS="-o \"$OUTPUT_DIR\""
          [[ "${{ github.event.inputs.generate_proprietary }}" == "false" ]] && AOSP_ARGS="$AOSP_ARGS --no-proprietary-files"
          
          timeout 600 python3 -m aospdtgen $AOSP_ARGS "$DUMP_PATH" 2>&1 | tee aospdtgen.log || \
          echo "âš ï¸ Completed with warnings"
          
          if [ ! -d "$OUTPUT_DIR" ] || [ -z "$(ls -A "$OUTPUT_DIR" 2>/dev/null)" ]; then
            echo "âŒ No output generated!"
            exit 1
          fi
          
          echo "âœ… Generated $(find "$OUTPUT_DIR" -type f | wc -l) files"
          echo "output_path=$OUTPUT_DIR" >> $GITHUB_OUTPUT

      - name: ðŸ“¦ Package & Upload
        run: |
          mkdir -p "$WORKSPACE/artifacts"
          cd "${{ env.OUTPUT_DIR }}"
          
          PKG="device_tree_${{ github.run_id }}"
          zip -r9 "$WORKSPACE/artifacts/${PKG}.zip" . 2>/dev/null || true
          tar -czf "$WORKSPACE/artifacts/${PKG}.tar.gz" . 2>/dev/null || true
          
          ls -lh "$WORKSPACE/artifacts/"

      - name: â˜ï¸ Upload
        uses: actions/upload-artifact@v4
        with:
          name: device-tree-${{ github.run_id }}
          path: ${{ github.workspace }}/artifacts/*
          retention-days: 30

      - name: ðŸ§¹ Cleanup
        if: ${{ always() }}
        run: |
          sudo umount "$WORKSPACE/mounted_partitions/"* 2>/dev/null || true
          rm -rf "$WORKSPACE/rom_download" "$WORKSPACE/rom_extracted" \
                 "$WORKSPACE/work_dir" "$WORKSPACE/mounted_partitions" \
                 "$WORKSPACE/dump" "${{ env.OUTPUT_DIR }}"
