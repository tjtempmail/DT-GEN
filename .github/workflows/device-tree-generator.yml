name: ðŸ“± AOSP Device Tree Generator Pro

on:
  workflow_dispatch:
    inputs:
      rom_url:
        description: 'ðŸ”— Direct link to stock ROM (GitHub Releases, Pixeldrain, Gofile, or your server - NOT MediaFire/Google Drive)'
        required: true
        type: string
      rom_type:
        description: 'ðŸ“¦ ROM Format (Auto-detect works for most)'
        required: true
        type: choice
        options:
          - 'auto-detect'
          - 'payload.bin (A/B OTA)'
          - 'super.img (Dynamic partitions)'
          - 'sparse_images (system.img/vendor.img)'
          - 'scatter_flashable (MTK/SP Flash Tool)'
          - 'zip_flat (Extracted images in ZIP)'
        default: 'auto-detect'
      device_codename:
        description: 'ðŸ·ï¸ Device Codename (optional, auto-detected)'
        required: false
        type: string
      brand:
        description: 'ðŸ¢ Brand (optional, auto-detected)'
        required: false
        type: string
      generate_proprietary:
        description: 'ðŸ” Generate proprietary-files.txt & extract-files.sh'
        required: true
        type: boolean
        default: true
      cleanup_after:
        description: 'ðŸ§¹ Cleanup workspace after completion'
        required: true
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  WORKSPACE: ${{ github.workspace }}
  OUTPUT_DIR: ${{ github.workspace }}/device_tree_output

jobs:
  generate-device-tree:
    runs-on: ubuntu-22.04
    timeout-minutes: 180
    
    steps:
      # ============================================================================
      # STEP 1: Checkout & Setup
      # ============================================================================
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4

      - name: ðŸ Setup Python ${{ env.PYTHON_VERSION }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: ðŸ› ï¸ Install System Dependencies
        run: |
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            aria2 p7zip-full p7zip-rar unrar unzip zip \
            cpio file liblz4-tool brotli simg2img img2simg \
            android-sdk-libsparse-utils erofs-utils f2fs-tools \
            git curl wget bc xz-utils lzma gzip \
            libxml2-utils python3-pip e2fsprogs mount \
            util-linux kmod

      - name: ðŸ”§ Install Android SDK & Python Tools
        run: |
          # Android SDK
          mkdir -p $HOME/android-sdk/cmdline-tools
          cd $HOME/android-sdk/cmdline-tools
          curl -sS https://dl.google.com/android/repository/commandlinetools-linux-11076708_latest.zip -o cmdline-tools.zip
          unzip -q cmdline-tools.zip && mv cmdline-tools latest
          echo "$HOME/android-sdk/cmdline-tools/latest/bin" >> $GITHUB_PATH
          echo "$HOME/android-sdk/platform-tools" >> $GITHUB_PATH
          yes | sdkmanager --licenses > /dev/null 2>&1 || true
          sdkmanager "platform-tools" > /dev/null 2>&1 || true
          
          # Python tools - Install all dependencies first
          python -m pip install --upgrade pip
          pip install numpy protobuf  # Install numpy first!
          pip install aospdtgen dumpyara pyaxmlparser
          
          # Install payload dumper for A/B OTA
          git clone --depth 1 https://github.com/vm03/payload_dumper.git /tmp/payload_dumper 2>/dev/null || true

      # ============================================================================
      # STEP 2: Download ROM with Validation
      # ============================================================================
      - name: â¬‡ï¸ Download ROM
        id: download
        run: |
          ROM_URL="${{ github.event.inputs.rom_url }}"
          
          # Clean filename
          ROM_FILENAME=$(basename "$ROM_URL" | sed 's/[?#].*$//' | sed 's/[^a-zA-Z0-9._-]/_/g')
          [[ "$ROM_FILENAME" =~ \.(zip|tar|md5|lz4|br|img|bin|tgz)$ ]] || ROM_FILENAME="rom.zip"
          
          echo "=========================================="
          echo "ðŸ“¥ DOWNLOADING ROM"
          echo "URL: $ROM_URL"
          echo "Filename: $ROM_FILENAME"
          echo "=========================================="
          
          mkdir -p $WORKSPACE/rom_download
          cd $WORKSPACE/rom_download
          
          # Try aria2c with multiple connections
          echo "Attempting download with aria2c..."
          if aria2c \
            --max-connection-per-server=16 \
            --split=16 \
            --min-split-size=1M \
            --max-tries=5 \
            --retry-wait=30 \
            --timeout=600 \
            --file-allocation=none \
            --summary-interval=30 \
            --console-log-level=warn \
            --download-result=full \
            --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36" \
            --allow-overwrite=true \
            --auto-file-renaming=false \
            -o "$ROM_FILENAME" \
            "$ROM_URL" 2>&1 | tee download.log; then
            
            echo "âœ… aria2c download completed"
          else
            echo "âš ï¸ aria2c failed, trying wget..."
            if wget --tries=5 --timeout=600 --progress=dot:giga \
                 --user-agent="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36" \
                 -O "$ROM_FILENAME" "$ROM_URL" 2>&1 | tee -a download.log; then
              echo "âœ… wget download completed"
            else
              echo "âš ï¸ wget failed, trying curl..."
              if curl -L --max-time 600 --retry 5 \
                   -A "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36" \
                   -o "$ROM_FILENAME" "$ROM_URL" 2>&1 | tee -a download.log; then
                echo "âœ… curl download completed"
              else
                echo "âŒ All download methods failed!"
                exit 1
              fi
            fi
          fi
          
          # Validate file exists
          if [ ! -f "$ROM_FILENAME" ]; then
            echo "âŒ Download failed - file not found!"
            exit 1
          fi
          
          FILE_SIZE=$(stat -c%s "$ROM_FILENAME" 2>/dev/null || stat -f%z "$ROM_FILENAME")
          echo ""
          echo "ðŸ“Š Download Statistics:"
          echo "   File: $ROM_FILENAME"
          echo "   Size: $FILE_SIZE bytes ($(numfmt --to=iec-i $FILE_SIZE))"
          
          # CRITICAL: Check if file is too small (HTML error page)
          if [ "$FILE_SIZE" -lt 1000000 ]; then
            echo ""
            echo "ðŸš¨ CRITICAL ERROR: File is too small ($FILE_SIZE bytes)!"
            echo "   This is likely an HTML error page, not a ROM."
            echo ""
            echo "ðŸ“„ File content preview (first 1000 bytes):"
            echo "----------------------------------------"
            head -c 1000 "$ROM_FILENAME"
            echo ""
            echo "----------------------------------------"
            echo ""
            echo "âŒ INVALID DOWNLOAD SOURCE"
            echo "ðŸ’¡ SOLUTIONS:"
            echo "   1. Use GitHub Releases (recommended)"
            echo "   2. Use Pixeldrain: https://pixeldrain.com"
            echo "   3. Use Gofile: https://gofile.io"
            echo "   4. Use your own direct HTTP server"
            echo "   5. DO NOT use MediaFire, Google Drive, or Mega share links"
            exit 1
          fi
          
          # Detect file type
          FILE_TYPE=$(file -b "$ROM_FILENAME")
          MIME_TYPE=$(file -b --mime-type "$ROM_FILENAME")
          echo "   Type: $FILE_TYPE"
          echo "   MIME: $MIME_TYPE"
          
          # Validate it's an archive or image
          if [[ "$FILE_TYPE" == *"HTML"* ]] || [[ "$MIME_TYPE" == *"text/html"* ]]; then
            echo "âŒ ERROR: Downloaded file is HTML, not a ROM!"
            exit 1
          fi
          
          # Calculate checksums
          echo ""
          echo "ðŸ” Calculating checksums..."
          (md5sum "$ROM_FILENAME" > "${ROM_FILENAME}.md5" && echo "   MD5: $(cut -d' ' -f1 < ${ROM_FILENAME}.md5)") &
          (sha256sum "$ROM_FILENAME" > "${ROM_FILENAME}.sha256" && echo "   SHA256: $(cut -d' ' -f1 < ${ROM_FILENAME}.sha256)") &
          wait
          
          echo ""
          echo "rom_path=$WORKSPACE/rom_download/$ROM_FILENAME" >> $GITHUB_OUTPUT
          echo "rom_filename=$ROM_FILENAME" >> $GITHUB_OUTPUT
          echo "rom_size=$FILE_SIZE" >> $GITHUB_OUTPUT
          echo "file_type=$FILE_TYPE" >> $GITHUB_OUTPUT
          echo "âœ… Download validation passed"

      # ============================================================================
      # STEP 3: Smart Multi-Format Extraction
      # ============================================================================
      - name: ðŸ”“ Smart Extraction (Auto-Detect Format)
        id: extract
        run: |
          ROM_PATH="${{ steps.download.outputs.rom_path }}"
          EXTRACT_DIR="$WORKSPACE/rom_extracted"
          WORK_DIR="$WORKSPACE/work_dir"
          
          mkdir -p "$EXTRACT_DIR" "$WORK_DIR"
          
          echo ""
          echo "=========================================="
          echo "ðŸ”“ EXTRACTION PHASE"
          echo "Source: $(basename "$ROM_PATH")"
          echo "=========================================="
          
          cd "$WORKSPACE/rom_download"
          
          # Detect ROM type based on content
          ROM_TYPE="${{ github.event.inputs.rom_type }}"
          
          if [[ "$ROM_TYPE" == "auto-detect" ]]; then
            echo "ðŸ” Auto-detecting ROM format..."
            
            # Check if it's a ZIP
            if [[ "$ROM_PATH" == *.zip ]] || file -b "$ROM_PATH" | grep -q "Zip"; then
              echo "ðŸ“¦ Detected: ZIP archive"
              
              # Extract ZIP first
              echo "   Extracting ZIP contents..."
              unzip -o -q "$ROM_PATH" -d "$EXTRACT_DIR" 2>/dev/null || \
              7z x "$ROM_PATH" -o"$EXTRACT_DIR" -y > /dev/null 2>&1 || true
              
              # Check what's inside
              echo "   Analyzing contents..."
              
              if [ -f "$EXTRACT_DIR/payload.bin" ]; then
                ROM_TYPE="payload"
                echo "   âœ… Found: payload.bin (A/B OTA format)"
              elif [ -f "$EXTRACT_DIR/super.img" ] || [ -f "$EXTRACT_DIR/Super.img" ]; then
                ROM_TYPE="super"
                echo "   âœ… Found: super.img (Dynamic partitions)"
              elif ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | grep -q scatter; then
                ROM_TYPE="scatter"
                echo "   âœ… Found: scatter file (MTK/SP Flash Tool)"
              elif ls "$EXTRACT_DIR"/*.img 2>/dev/null | grep -qE "(system|vendor|boot)"; then
                ROM_TYPE="sparse"
                echo "   âœ… Found: .img files (Sparse partition images)"
              else
                # Check nested archives
                echo "   Checking for nested archives..."
                find "$EXTRACT_DIR" -name "*.zip" -exec unzip -o -q {} -d "$EXTRACT_DIR" \; 2>/dev/null || true
                find "$EXTRACT_DIR" -name "*.tar*" -exec tar -xf {} -C "$EXTRACT_DIR" \; 2>/dev/null || true
                
                # Re-check
                if [ -f "$EXTRACT_DIR/payload.bin" ]; then
                  ROM_TYPE="payload"
                elif ls "$EXTRACT_DIR"/*.img 2>/dev/null | grep -q system; then
                  ROM_TYPE="sparse"
                fi
              fi
            elif [[ "$ROM_PATH" == *.tar* ]] || file -b "$ROM_PATH" | grep -q "tar"; then
              echo "ðŸ“¦ Detected: TAR archive"
              tar -xf "$ROM_PATH" -C "$EXTRACT_DIR" 2>/dev/null || true
              ROM_TYPE="sparse"
            else
              echo "ðŸ“¦ Treating as raw image"
              cp "$ROM_PATH" "$EXTRACT_DIR/"
              ROM_TYPE="sparse"
            fi
          else
            # User specified type
            echo "ðŸ“¦ User specified type: $ROM_TYPE"
            if [[ "$ROM_PATH" == *.zip ]]; then
              unzip -o -q "$ROM_PATH" -d "$EXTRACT_DIR" 2>/dev/null || true
            fi
          fi
          
          echo ""
          echo "ðŸ”§ Processing ROM type: $ROM_TYPE"
          echo "----------------------------------------"
          
          # Process based on ROM type
          case "$ROM_TYPE" in
            payload*)
              echo "ðŸ”§ Extracting payload.bin..."
              if [ -f "$EXTRACT_DIR/payload.bin" ]; then
                cd /tmp/payload_dumper
                python3 payload_dumper.py "$EXTRACT_DIR/payload.bin" --out "$WORK_DIR" 2>&1 | head -50 || {
                  echo "âš ï¸ payload_dumper failed, trying alternative..."
                  # Manual extraction with ota_extractor if available
                  if command -v ota_extractor &> /dev/null; then
                    ota_extractor --payload "$EXTRACT_DIR/payload.bin" --output_dir "$WORK_DIR" 2>/dev/null || true
                  fi
                }
                cd "$WORKSPACE"
              fi
              ;;
              
            super*)
              echo "ðŸ”§ Extracting super.img (Dynamic partitions)..."
              SUPER_IMG=$(ls "$EXTRACT_DIR"/[Ss]uper.img 2>/dev/null | head -1)
              if [ -n "$SUPER_IMG" ]; then
                echo "   Found: $SUPER_IMG"
                
                # Convert sparse super.img to raw first
                echo "   Converting sparse super.img to raw..."
                simg2img "$SUPER_IMG" "$WORK_DIR/super.raw.img" 2>/dev/null || {
                  echo "âš ï¸ simg2img failed, trying to copy as-is..."
                  cp "$SUPER_IMG" "$WORK_DIR/super.raw.img" 2>/dev/null || true
                }
                
                # Check if we got a raw image
                if [ -f "$WORK_DIR/super.raw.img" ]; then
                  echo "   âœ… Raw super image created"
                  
                  # Try to use lpunpack if available
                  if command -v lpunpack &> /dev/null; then
                    echo "   Using lpunpack to extract partitions..."
                    cd "$WORK_DIR"
                    lpunpack super.raw.img . 2>&1 | head -30 || {
                      echo "âš ï¸ lpunpack failed, trying manual extraction..."
                    }
                    cd "$WORKSPACE"
                  fi
                  
                  # Try unsuper as alternative
                  if command -v unsuper &> /dev/null; then
                    echo "   Trying unsuper..."
                    cd "$WORK_DIR"
                    unsuper super.raw.img . 2>&1 | head -30 || {
                      echo "âš ï¸ unsuper failed (this is OK if lpunpack worked)"
                    }
                    cd "$WORKSPACE"
                  fi
                  
                  # Check if we extracted anything
                  if ls "$WORK_DIR"/*.img 2>/dev/null | grep -q .; then
                    echo "   âœ… Partitions extracted from super.img"
                  else
                    echo "   âš ï¸ No partitions extracted, will try to mount super.img directly"
                  fi
                else
                  echo "   âŒ Failed to create raw super image"
                fi
              else
                echo "   âŒ super.img not found!"
              fi
              ;;
              
            scatter*)
              echo "ðŸ”§ Processing MTK Scatter ROM..."
              SCATTER=$(ls "$EXTRACT_DIR"/*scatter*.txt 2>/dev/null | head -1)
              echo "   Scatter file: $(basename "$SCATTER")"
              
              # Handle sparse chunks for system
              if ls "$EXTRACT_DIR"/system_sparse_chunk* 2>/dev/null | grep -q .; then
                echo "   ðŸ“¦ Combining system sparse chunks..."
                cat "$EXTRACT_DIR"/system_sparse_chunk* > "$WORK_DIR/system.img" 2>/dev/null || true
              elif [ -f "$EXTRACT_DIR/system.img" ]; then
                cp "$EXTRACT_DIR/system.img" "$WORK_DIR/" 2>/dev/null || true
              fi
              
              # Handle vendor chunks
              if ls "$EXTRACT_DIR"/vendor_sparse_chunk* 2>/dev/null | grep -q .; then
                echo "   ðŸ“¦ Combining vendor sparse chunks..."
                cat "$EXTRACT_DIR"/vendor_sparse_chunk* > "$WORK_DIR/vendor.img" 2>/dev/null || true
              elif [ -f "$EXTRACT_DIR/vendor.img" ]; then
                cp "$EXTRACT_DIR/vendor.img" "$WORK_DIR/" 2>/dev/null || true
              fi
              
              # Copy other important images
              for img in boot.img dtbo.img vbmeta.img recovery.img; do
                [ -f "$EXTRACT_DIR/$img" ] && cp "$EXTRACT_DIR/$img" "$WORK_DIR/" 2>/dev/null || true
              done
              ;;
              
            sparse*|*flat*)
              echo "ðŸ”§ Processing sparse images..."
              # Copy all img files to work dir
              find "$EXTRACT_DIR" -name "*.img" -type f -exec cp {} "$WORK_DIR/" \; 2>/dev/null || true
              ;;
          esac
          
          echo ""
          echo "ðŸ”„ Converting sparse images to raw..."
          cd "$WORK_DIR"
          
          # List what we have before conversion
          echo "   Files in work_dir before conversion:"
          ls -lh *.img 2>/dev/null | head -20 || echo "   (No .img files found)"
          
          # Convert all sparse images
          for img in *.img; do
            if [ -f "$img" ]; then
              # Check if it's a sparse image
              if file "$img" | grep -q "sparse"; then
                echo "   Converting sparse: $img"
                simg2img "$img" "${img%.img}.raw.img" 2>/dev/null && {
                  rm -f "$img"
                  echo "     âœ… Converted to ${img%.img}.raw.img"
                } || {
                  echo "     âš ï¸ simg2img failed for $img"
                  # Try to rename anyway in case it's already raw
                  mv "$img" "${img%.img}.raw.img" 2>/dev/null || true
                }
              else
                # Not sparse, just rename
                echo "   Renaming to raw: $img"
                mv "$img" "${img%.img}.raw.img" 2>/dev/null || true
              fi
            fi
          done
          
          echo ""
          echo "ðŸ“‚ Files after conversion:"
          ls -lh *.raw.img 2>/dev/null | head -20 || echo "   (No raw images found)"
          
          # Mount raw images to extract contents
          echo ""
          echo "ðŸ“‚ Mounting partitions to extract contents..."
          mkdir -p "$WORKSPACE/mounted_partitions"
          
          # Mount each raw image and copy contents
          for raw_img in *.raw.img; do
            if [ -f "$raw_img" ]; then
              part_name=$(basename "$raw_img" .raw.img)
              mount_point="$WORKSPACE/mounted_partitions/$part_name"
              
              echo "   Mounting: $part_name"
              mkdir -p "$mount_point"
              
              # Try ext4 first, then auto
              if sudo mount -o loop,ro -t ext4 "$raw_img" "$mount_point" 2>/dev/null; then
                echo "     âœ… Mounted as ext4"
              elif sudo mount -o loop,ro -t auto "$raw_img" "$mount_point" 2>/dev/null; then
                echo "     âœ… Mounted (auto)"
              else
                echo "     âš ï¸ Could not mount (skipping)"
                rmdir "$mount_point" 2>/dev/null || true
                continue
              fi
              
              # Copy mounted contents to a clean directory
              dest_dir="$WORKSPACE/dump/$part_name"
              mkdir -p "$dest_dir"
              echo "     ðŸ“¦ Copying contents to $dest_dir"
              sudo cp -a "$mount_point/." "$dest_dir/" 2>/dev/null || true
              sudo umount "$mount_point" 2>/dev/null || true
            fi
          done
          
          # Also try to mount super.raw.img directly if it exists and we haven't extracted partitions
          if [ -f "$WORK_DIR/super.raw.img" ] && [ ! -d "$WORKSPACE/dump/system" ]; then
            echo ""
            echo "ðŸ”§ Attempting to mount super.raw.img directly..."
            mount_point="$WORKSPACE/mounted_partitions/super"
            mkdir -p "$mount_point"
            
            # Try to mount super partition
            if sudo mount -o loop,ro -t auto "$WORK_DIR/super.raw.img" "$mount_point" 2>/dev/null; then
              echo "   âœ… Mounted super partition"
              # Look for logical partitions inside
              for subpart in system vendor product system_ext odm; do
                if [ -d "$mount_point/$subpart" ]; then
                  echo "   ðŸ“¦ Found logical partition: $subpart"
                  mkdir -p "$WORKSPACE/dump/$subpart"
                  sudo cp -a "$mount_point/$subpart/." "$WORKSPACE/dump/$subpart/" 2>/dev/null || true
                fi
              done
              sudo umount "$mount_point" 2>/dev/null || true
            else
              echo "   âš ï¸ Could not mount super partition directly"
              rmdir "$mount_point" 2>/dev/null || true
            fi
          fi
          
          # Determine final dump path
          echo ""
          echo "ðŸ” Locating system partition..."
          
          if [ -d "$WORKSPACE/dump/system" ]; then
            DUMP_PATH="$WORKSPACE/dump"
            echo "   âœ… Found: $DUMP_PATH/system"
          elif [ -d "$WORKSPACE/dump/system_ext" ]; then
            DUMP_PATH="$WORKSPACE/dump"
            echo "   âœ… Found: $DUMP_PATH/system_ext"
          else
            # Search for build.prop
            BUILD_PROP=$(find "$WORKSPACE/dump" -name "build.prop" -type f 2>/dev/null | head -1)
            if [ -n "$BUILD_PROP" ]; then
              SYS_DIR=$(dirname "$BUILD_PROP")
              DUMP_PATH=$(dirname "$SYS_DIR")
              echo "   âœ… Found system at: $SYS_DIR"
            else
              echo "   âŒ No system partition found!"
              echo ""
              echo "ðŸ“‚ Dump directory contents:"
              find "$WORKSPACE/dump" -type f -o -type d 2>/dev/null | head -30 || echo "   (Empty or not found)"
              echo ""
              echo "ðŸ“‚ Work directory contents:"
              ls -la "$WORK_DIR" 2>/dev/null || echo "   (Empty or not found)"
              echo ""
              echo "ðŸ“‚ Mounted partitions:"
              ls -la "$WORKSPACE/mounted_partitions/" 2>/dev/null || echo "   (None)"
              exit 1
            fi
          fi
          
          echo ""
          echo "=========================================="
          echo "âœ… EXTRACTION COMPLETE"
          echo "Dump path: $DUMP_PATH"
          echo "=========================================="
          
          # List structure
          echo "ðŸ“ Final structure:"
          find "$DUMP_PATH" -maxdepth 2 -type d 2>/dev/null | head -20 || true
          
          echo "dump_path=$DUMP_PATH" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 4: Generate Device Tree with aospdtgen
      # ============================================================================
      - name: ðŸŒ³ Generate Device Tree
        id: generate
        run: |
          DUMP_PATH="${{ steps.extract.outputs.dump_path }}"
          OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
          
          echo ""
          echo "=========================================="
          echo "ðŸŒ³ GENERATING DEVICE TREE"
          echo "=========================================="
          
          # Pre-check
          if [ ! -d "$DUMP_PATH" ]; then
            echo "âŒ ERROR: Dump path does not exist: $DUMP_PATH"
            exit 1
          fi
          
          # Critical: Verify system partition exists (required by aospdtgen)
          echo "ðŸ” Verifying system partition..."
          SYS_FOUND=false
          
          if [ -d "$DUMP_PATH/system" ]; then
            echo "   âœ… system/ directory exists"
            SYS_FOUND=true
          fi
          
          if [ -d "$DUMP_PATH/system_ext" ]; then
            echo "   âœ… system_ext/ directory exists"
            SYS_FOUND=true
          fi
          
          if [ "$SYS_FOUND" != "true" ]; then
            echo ""
            echo "âŒ CRITICAL ERROR: No system or system_ext partition found!"
            echo ""
            echo "ðŸ’¡ This usually means:"
            echo "   1. The ROM download was incomplete/invalid"
            echo "   2. The extraction failed to mount sparse images"
            echo "   3. This is a custom ROM format not supported"
            echo ""
            echo "ðŸ“‚ Dump directory contents:"
            ls -la "$DUMP_PATH" || true
            echo ""
            echo "ðŸ“‚ All directories:"
            find "$DUMP_PATH" -type d 2>/dev/null | head -30 || true
            exit 1
          fi
          
          # Check for build.prop
          if [ ! -f "$DUMP_PATH/system/build.prop" ] && [ ! -f "$DUMP_PATH/system_ext/build.prop" ]; then
            echo "âš ï¸ WARNING: build.prop not found in system directories"
          fi
          
          mkdir -p "$OUTPUT_DIR"
          
          echo ""
          echo "âš™ï¸ Running aospdtgen..."
          echo "   Input:  $DUMP_PATH"
          echo "   Output: $OUTPUT_DIR"
          
          # Build arguments
          AOSP_ARGS="-o \"$OUTPUT_DIR\""
          [[ "${{ github.event.inputs.generate_proprietary }}" == "false" ]] && AOSP_ARGS="$AOSP_ARGS --no-proprietary-files"
          
          echo "   Args: $AOSP_ARGS"
          echo ""
          
          # Run with timeout and capture output
          if timeout 600 bash -c "python3 -m aospdtgen $AOSP_ARGS \"$DUMP_PATH\"" 2>&1 | tee aospdtgen.log; then
            echo ""
            echo "âœ… aospdtgen completed successfully"
          else
            EXIT_CODE=$?
            echo ""
            echo "âš ï¸ aospdtgen exited with code $EXIT_CODE"
            echo "ðŸ“„ Last 50 lines of log:"
            tail -50 aospdtgen.log 2>/dev/null || true
          fi
          
          # Verify output was created
          if [ ! -d "$OUTPUT_DIR" ] || [ -z "$(ls -A "$OUTPUT_DIR" 2>/dev/null)" ]; then
            echo ""
            echo "âŒ ERROR: No device tree was generated!"
            echo "   The output directory is empty."
            echo ""
            echo "ðŸ’¡ Possible causes:"
            echo "   1. aospdtgen couldn't find required partitions"
            echo "   2. The ROM structure is unsupported"
            echo "   3. Missing proprietary files detection"
            exit 1
          fi
          
          # Success
          FILE_COUNT=$(find "$OUTPUT_DIR" -type f 2>/dev/null | wc -l)
          echo ""
          echo "=========================================="
          echo "âœ… DEVICE TREE GENERATED"
          echo "Files created: $FILE_COUNT"
          echo "=========================================="
          
          echo ""
          echo "ðŸ“ Generated files:"
          find "$OUTPUT_DIR" -type f 2>/dev/null | sort | head -40 || true
          
          echo "output_path=$OUTPUT_DIR" >> $GITHUB_OUTPUT
          echo "file_count=$FILE_COUNT" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 5: Post-Processing & Validation
      # ============================================================================
      - name: âœ… Validate & Create Report
        id: validate
        run: |
          OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
          
          echo ""
          echo "ðŸ” Validating device tree..."
          
          # Create validation report
          REPORT="$OUTPUT_DIR/DEVICE_TREE_REPORT.txt"
          
          cat > "$REPORT" << EOF
          ============================================
          AOSP DEVICE TREE GENERATION REPORT
          ============================================
          Generated: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Workflow Run: ${{ github.run_id }}
          Repository: ${{ github.repository }}
          
          SOURCE ROM:
          - URL: ${{ github.event.inputs.rom_url }}
          - Type: ${{ github.event.inputs.rom_type }}
          
          ESSENTIAL FILES CHECK:
          EOF
          
          ESSENTIAL=(
            "Android.bp:Build system file"
            "Android.mk:Legacy build file"
            "BoardConfig.mk:Board configuration"
            "device.mk:Device makefile"
            "extract-files.sh:Vendor extraction script"
            "setup-makefiles.sh:Makefile setup"
            "proprietary-files.txt:Proprietary blobs list"
          )
          
          FOUND_COUNT=0
          for item in "${ESSENTIAL[@]}"; do
            IFS=':' read -r file desc <<< "$item"
            count=$(find "$OUTPUT_DIR" -name "$file" -type f 2>/dev/null | wc -l)
            if [ "$count" -gt 0 ]; then
              echo "âœ… $file: Found ($count) - $desc" >> "$REPORT"
              ((FOUND_COUNT++))
            else
              echo "âš ï¸ $file: NOT FOUND - $desc" >> "$REPORT"
            fi
          done
          
          echo "" >> "$REPORT"
          echo "VALIDATION SCORE: $FOUND_COUNT/${#ESSENTIAL[@]} essential files" >> "$REPORT"
          echo "" >> "$REPORT"
          echo "DIRECTORY STRUCTURE:" >> "$REPORT"
          tree "$OUTPUT_DIR" 2>/dev/null >> "$REPORT" || \
          find "$OUTPUT_DIR" -print 2>/dev/null | sed -e 's;[^/]*/;|____;g;s;____|; |;g' >> "$REPORT"
          
          cat "$REPORT"
          
          echo "validation_score=$FOUND_COUNT" >> $GITHUB_OUTPUT

      # ============================================================================
      # STEP 6: Package Artifacts
      # ============================================================================
      - name: ðŸ“¦ Package Artifacts
        run: |
          OUTPUT_DIR="${{ env.OUTPUT_DIR }}"
          mkdir -p "$WORKSPACE/artifacts"
          
          # Get device info for naming
          BRAND="${{ github.event.inputs.brand }}"
          CODENAME="${{ github.event.inputs.device_codename }}"
          
          # Try to extract from device tree if not provided
          if [ -z "$BRAND" ] && [ -f "$OUTPUT_DIR/AndroidProducts.mk" ]; then
            BRAND=$(grep -oP 'LOCAL_DIR.*device/\K[^/]+' "$OUTPUT_DIR/AndroidProducts.mk" 2>/dev/null | head -1)
          fi
          if [ -z "$CODENAME" ] && [ -f "$OUTPUT_DIR/AndroidProducts.mk" ]; then
            CODENAME=$(grep -oP 'LOCAL_DIR.*device/[^/]+/\K[^[:space:]]+' "$OUTPUT_DIR/AndroidProducts.mk" 2>/dev/null | head -1)
          fi
          
          # Fallbacks
          [ -z "$BRAND" ] && BRAND="unknown"
          [ -z "$CODENAME" ] && CODENAME="device"
          
          SAFE_BRAND=$(echo "$BRAND" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-' | cut -c1-15)
          SAFE_CODENAME=$(echo "$CODENAME" | tr '[:upper:]' '[:lower:]' | tr -cd '[:alnum:]-' | cut -c1-20)
          
          PKG_NAME="device_${SAFE_BRAND}_${SAFE_CODENAME}_dtgen"
          
          echo ""
          echo "ðŸ“¦ Packaging: $PKG_NAME"
          
          cd "$OUTPUT_DIR"
          
          # Create ZIP
          zip -r9 "$WORKSPACE/artifacts/${PKG_NAME}.zip" . -x "*.git*" 2>/dev/null || \
          (echo "âš ï¸ zip failed, using tar only" && false)
          
          # Create TAR.GZ (more reliable)
          tar -czf "$WORKSPACE/artifacts/${PKG_NAME}.tar.gz" .
          
          # Create info file
          cat > "$WORKSPACE/artifacts/${PKG_NAME}_INFO.txt" << EOF
          Device Tree Package
          ===================
          Brand:    $BRAND
          Codename: $CODENAME
          Package:  $PKG_NAME
          Date:     $(date -u +"%Y-%m-%d %H:%M:%S UTC")
          Source:   ${{ github.event.inputs.rom_url }}
          
          Files:    $(find "$OUTPUT_DIR" -type f | wc -l)
          
          Generated by GitHub Actions
          Run: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          EOF
          
          echo ""
          echo "âœ… Artifacts created:"
          ls -lh "$WORKSPACE/artifacts/"

      # ============================================================================
      # STEP 7: Upload to GitHub
      # ============================================================================
      - name: â˜ï¸ Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: device-tree-${{ github.run_id }}
          path: ${{ github.workspace }}/artifacts/*
          retention-days: 30
          if-no-files-found: error

      # ============================================================================
      # STEP 8: Cleanup
      # ============================================================================
      - name: ðŸ§¹ Cleanup
        if: ${{ github.event.inputs.cleanup_after == 'true' && always() }}
        run: |
          echo "Cleaning up..."
          sudo umount "$WORKSPACE/mounted_partitions/"* 2>/dev/null || true
          rm -rf "$WORKSPACE/rom_download" "$WORKSPACE/rom_extracted" \
                 "$WORKSPACE/work_dir" "$WORKSPACE/mounted_partitions" \
                 "$WORKSPACE/dump" "${{ env.OUTPUT_DIR }}"
          echo "âœ… Cleanup complete"
          df -h

      # ============================================================================
      # STEP 9: Final Summary
      # ============================================================================
      - name: ðŸ“‹ Final Summary
        if: always()
        run: |
          echo "## ðŸ“± Device Tree Generation Report" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "ðŸŸ¢ **STATUS: SUCCESS**" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸ”´ **STATUS: FAILED**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "|--------|-------|" >> $GITHUB_STEP_SUMMARY
          echo "| **ROM URL** | ${{ github.event.inputs.rom_url }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **ROM Type** | ${{ github.event.inputs.rom_type }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Brand** | ${{ github.event.inputs.brand }} |" >> $GITHUB_STEP_SUMMARY
          echo "| **Codename** | ${{ github.event.inputs.device_codename }} |" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ job.status }}" == "success" ]; then
            echo "### âœ… Generated Files" >> $GITHUB_STEP_SUMMARY
            echo "- Device Tree ZIP" >> $GITHUB_STEP_SUMMARY
            echo "- Device Tree TAR.GZ" >> $GITHUB_STEP_SUMMARY
            echo "- Validation Report" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ“¥ [Download Artifacts](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
          else
            echo "### âŒ Error Details" >> $GITHUB_STEP_SUMMARY
            echo "Check the logs above for specific error messages." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "ðŸ’¡ **Common fixes:**" >> $GITHUB_STEP_SUMMARY
            echo "1. Use GitHub Releases instead of MediaFire" >> $GITHUB_STEP_SUMMARY
            echo "2. Ensure ROM is >1GB (not an HTML page)" >> $GITHUB_STEP_SUMMARY
            echo "3. Verify ROM contains system.img or payload.bin" >> $GITHUB_STEP_SUMMARY
          fi
