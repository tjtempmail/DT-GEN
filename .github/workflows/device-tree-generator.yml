name: ü§ñ Device Tree Generator Pro
run-name: Generate Device Tree from ${{ inputs.rom_url }}

on:
  workflow_dispatch:
    inputs:
      rom_url:
        description: 'üì¶ Direct URL to Stock ROM ZIP (OTA/Full ROM)'
        required: true
        type: string
      rom_type:
        description: 'üì± ROM Type'
        required: true
        type: choice
        options:
          - 'auto'
          - 'ota'
          - 'fastboot'
          - 'kdz'
          - 'tar_md5'
        default: 'auto'
      device_codename:
        description: 'üè∑Ô∏è Device Codename (optional, auto-detected if empty)'
        required: false
        type: string
      manufacturer:
        description: 'üè≠ Manufacturer (optional, auto-detected if empty)'
        required: false
        type: string
      generate_twrp:
        description: 'üîÑ Also Generate TWRP Device Tree'
        required: false
        type: boolean
        default: false
      upload_artifacts:
        description: '‚òÅÔ∏è Upload Artifacts to Release'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  WORKSPACE: ${{ github.workspace }}
  OUTPUT_DIR: ${{ github.workspace }}/output

jobs:
  extract-and-generate:
    name: üîß Extract Firmware & Generate Device Tree
    runs-on: ubuntu-24.04
    timeout-minutes: 120
    
    steps:
      - name: üì• Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: üêç Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}

      - name: üîß Install System Dependencies
        run: |
          echo "::group::Installing system packages..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            unace unrar zip unzip p7zip-full p7zip-rar \
            sharutils rar uudeview mpack arj cabextract \
            rename liblzma-dev brotli lz4 \
            protobuf-compiler git gawk cpio \
            erofs-utils android-sdk-libsparse-utils \
            libxml2-utils bc curl wget \
            python3-dev build-essential file device-tree-compiler \
            || echo "Some packages failed, continuing..."
          echo "::endgroup::"

      - name: üì¶ Install Python Tools
        run: |
          echo "::group::Installing Python packages..."
          pip install --upgrade pip setuptools wheel
          pip install dumpyara aospdtgen twrpdtgen
          pip install \
            extract-dtb pycryptodome protobuf backports.lzma \
            requests tqdm colorama lz4 zstandard pyyaml lxml
          echo "::endgroup::"

      - name: ‚¨áÔ∏è Download Firmware
        id: download
        run: |
          echo "::group::Downloading firmware..."
          mkdir -p ${{ env.OUTPUT_DIR }}
          DOWNLOAD_DIR="${{ env.WORKSPACE }}/downloads"
          mkdir -p "$DOWNLOAD_DIR"
          
          FILENAME=$(basename "${{ inputs.rom_url }}" | cut -d'?' -f1 | cut -d'#' -f1)
          [[ -z "$FILENAME" ]] && FILENAME="firmware.zip"
          
          echo "üì• Downloading: $FILENAME"
          curl -L -o "$DOWNLOAD_DIR/$FILENAME" --progress-bar "${{ inputs.rom_url }}"
          
          if [[ ! -f "$DOWNLOAD_DIR/$FILENAME" ]]; then
            echo "‚ùå Download failed!"
            exit 1
          fi
          
          echo "‚úÖ Downloaded: $(du -h $DOWNLOAD_DIR/$FILENAME | cut -f1)"
          echo "firmware_path=$DOWNLOAD_DIR/$FILENAME" >> $GITHUB_OUTPUT
          echo "firmware_name=$FILENAME" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: üóÇÔ∏è Extract Firmware with Dumpyara
        id: dumpyara
        run: |
          echo "::group::Extracting firmware..."
          FIRMWARE_PATH="${{ steps.download.outputs.firmware_path }}"
          DUMP_DIR="${{ env.OUTPUT_DIR }}/dump"
          mkdir -p "$DUMP_DIR"
          
          echo "üöÄ Running dumpyara..."
          dumpyara "$FIRMWARE_PATH" "$DUMP_DIR" 2>&1 | tee "${{ env.OUTPUT_DIR }}/dumpyara.log"
          
          # Debug: Show dump directory structure
          echo "üìÅ Dump directory structure:"
          find "$DUMP_DIR" -maxdepth 3 -type d | head -20
          
          # Find the correct extraction path
          # dumpyara creates subdirectories like: dump/system/ or dump/[codename]/system/
          EXTRACTED_DIR=""
          
          # Check various possible locations
          if [[ -d "$DUMP_DIR/system" ]]; then
            EXTRACTED_DIR="$DUMP_DIR"
          elif [[ -d "$DUMP_DIR/system/system" ]]; then
            EXTRACTED_DIR="$DUMP_DIR"
          else
            # Look for system directory deeper
            SYS_DIR=$(find "$DUMP_DIR" -maxdepth 3 -type d -name "system" | head -1)
            if [[ -n "$SYS_DIR" ]]; then
              EXTRACTED_DIR=$(dirname "$SYS_DIR")
            fi
          fi
          
          # If still not found, check for payload.bin extraction results
          if [[ -z "$EXTRACTED_DIR" ]] || [[ ! -d "$EXTRACTED_DIR/system" ]]; then
            # Look for any directory containing build.prop
            BUILD_PROP_DIR=$(find "$DUMP_DIR" -name "build.prop" -type f | head -1 | xargs dirname 2>/dev/null)
            if [[ -n "$BUILD_PROP_DIR" ]]; then
              # Go up to find system root
              if [[ "$BUILD_PROP_DIR" == */system ]]; then
                EXTRACTED_DIR=$(dirname "$BUILD_PROP_DIR")
              else
                EXTRACTED_DIR="$BUILD_PROP_DIR"
              fi
            fi
          fi
          
          if [[ -z "$EXTRACTED_DIR" ]] || [[ ! -d "$EXTRACTED_DIR" ]]; then
            echo "‚ùå Could not find valid extraction!"
            echo "Dump contents:"
            ls -laR "$DUMP_DIR" | head -50
            exit 1
          fi
          
          echo "‚úÖ Found extraction at: $EXTRACTED_DIR"
          echo "Contents:"
          ls -la "$EXTRACTED_DIR"
          
          # Check for system partition
          if [[ ! -d "$EXTRACTED_DIR/system" ]]; then
            echo "‚ö†Ô∏è Warning: No system directory found!"
          fi
          
          echo "extracted_path=$EXTRACTED_DIR" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: üîß Prepare for AOSP DT Gen
        id: prepare
        run: |
          echo "::group::Preparing for aospdtgen..."
          EXTRACTED_PATH="${{ steps.dumpyara.outputs.extracted_path }}"
          PREPARED_DIR="${{ env.OUTPUT_DIR }}/prepared"
          
          mkdir -p "$PREPARED_DIR"
          
          # aospdtgen expects partitions as directories in the root
          # Check if we need to reorganize
          if [[ -d "$EXTRACTED_PATH/system" ]]; then
            echo "‚úÖ Partitions already in correct location"
            PREPARED_PATH="$EXTRACTED_PATH"
          else
            echo "üîÑ Reorganizing partition structure..."
            # Find all partition images and mount/extract them if needed
            # For now, symlink the found structure
            ln -sf "$EXTRACTED_PATH" "$PREPARED_DIR/firmware"
            PREPARED_PATH="$PREPARED_DIR/firmware"
          fi
          
          # Debug: Show what aospdtgen will see
          echo "üìÅ Final structure for aospdtgen:"
          ls -la "$PREPARED_PATH"
          if [[ -d "$PREPARED_PATH/system" ]]; then
            echo "System partition contents:"
            ls -la "$PREPARED_PATH/system" | head -20
          fi
          
          echo "prepared_path=$PREPARED_PATH" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: üå≥ Generate AOSP Device Tree
        id: aospdtgen
        run: |
          echo "::group::Generating AOSP device tree..."
          PREPARED_PATH="${{ steps.prepare.outputs.prepared_path }}"
          DT_DIR="${{ env.OUTPUT_DIR }}/device-tree-aosp"
          
          mkdir -p "$DT_DIR"
          
          echo "üå≤ Running aospdtgen..."
          echo "Input: $PREPARED_PATH"
          echo "Output: $DT_DIR"
          
          # Check if system exists
          if [[ ! -d "$PREPARED_PATH/system" ]]; then
            echo "‚ùå ERROR: system partition not found at $PREPARED_PATH/system"
            echo "Available directories:"
            find "$PREPARED_PATH" -maxdepth 2 -type d
            exit 1
          fi
          
          # Run aospdtgen
          aospdtgen -o "$DT_DIR" "$PREPARED_PATH" 2>&1 | tee "${{ env.OUTPUT_DIR }}/aospdtgen.log"
          
          FILE_COUNT=$(find "$DT_DIR" -type f 2>/dev/null | wc -l)
          echo "‚úÖ Generated $FILE_COUNT files"
          
          if [[ $FILE_COUNT -eq 0 ]]; then
            echo "‚ùå No files generated!"
            exit 1
          fi
          
          echo "aosp_dt_path=$DT_DIR" >> $GITHUB_OUTPUT
          echo "aosp_file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: üîÑ Generate TWRP Device Tree (Optional)
        if: inputs.generate_twrp == true
        id: twrpdtgen
        run: |
          echo "::group::Generating TWRP device tree..."
          EXTRACTED_PATH="${{ steps.dumpyara.outputs.extracted_path }}"
          TWRP_DIR="${{ env.OUTPUT_DIR }}/device-tree-twrp"
          mkdir -p "$TWRP_DIR"
          
          RECOVERY_IMG=$(find "$EXTRACTED_PATH" -maxdepth 3 -name "recovery.img" | head -1)
          BOOT_IMG=$(find "$EXTRACTED_PATH" -maxdepth 3 -name "boot.img" | head -1)
          TARGET_IMG="${RECOVERY_IMG:-$BOOT_IMG}"
          
          if [[ -z "$TARGET_IMG" ]]; then
            echo "‚ö†Ô∏è No recovery/boot image found"
            echo "twrp_status=skipped" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi
          
          echo "üîÑ Processing: $TARGET_IMG"
          twrpdtgen -o "$TWRP_DIR" "$TARGET_IMG" 2>&1 | tee "${{ env.OUTPUT_DIR }}/twrpdtgen.log" || true
          
          TWRP_COUNT=$(find "$TWRP_DIR" -type f 2>/dev/null | wc -l)
          echo "twrp_dt_path=$TWRP_DIR" >> $GITHUB_OUTPUT
          echo "twrp_status=completed" >> $GITHUB_OUTPUT
          echo "twrp_file_count=$TWRP_COUNT" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: üì¶ Package & Upload
        run: |
          echo "::group::Packaging..."
          cd ${{ env.OUTPUT_DIR }}
          
          if [[ -d "device-tree-aosp" ]] && [[ "$(ls -A device-tree-aosp 2>/dev/null)" ]]; then
            tar -czf aosp-device-tree.tar.gz device-tree-aosp/
            echo "‚úÖ AOSP DT: $(du -h aosp-device-tree.tar.gz | cut -f1)"
          fi
          
          if [[ -d "device-tree-twrp" ]] && [[ "$(ls -A device-tree-twrp 2>/dev/null)" ]]; then
            tar -czf twrp-device-tree.tar.gz device-tree-twrp/
            echo "‚úÖ TWRP DT: $(du -h twrp-device-tree.tar.gz | cut -f1)"
          fi
          
          cat > GENERATION_REPORT.md << EOF
          # Device Tree Generation Report
          
          **ROM**: ${{ inputs.rom_url }}  
          **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
          **AOSP Files**: ${{ steps.aospdtgen.outputs.aosp_file_count }}  
          **TWRP Status**: ${{ steps.twrpdtgen.outputs.twrp_status || 'N/A' }}
          EOF
          
          ls -lh *.tar.gz 2>/dev/null || echo "No archives"
          echo "::endgroup::"

      - name: ‚òÅÔ∏è Upload Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: device-tree-${{ github.run_id }}
          path: |
            ${{ env.OUTPUT_DIR }}/*.tar.gz
            ${{ env.OUTPUT_DIR }}/*.log
            ${{ env.OUTPUT_DIR }}/*.md
          retention-days: 30
          if-no-files-found: warn
