name: ðŸ¤– Device Tree Generator Pro
run-name: Generate Device Tree from ${{ inputs.rom_url }}

on:
  workflow_dispatch:
    inputs:
      rom_url:
        description: 'ðŸ“¦ Direct URL to Stock ROM ZIP (OTA/Full ROM)'
        required: true
        type: string
      rom_type:
        description: 'ðŸ“± ROM Type'
        required: true
        type: choice
        options:
          - 'auto'
          - 'ota'
          - 'fastboot'
          - 'kdz'
          - 'tar_md5'
        default: 'auto'
      device_codename:
        description: 'ðŸ·ï¸ Device Codename (optional, auto-detected if empty)'
        required: false
        type: string
      manufacturer:
        description: 'ðŸ­ Manufacturer (optional, auto-detected if empty)'
        required: false
        type: string
      generate_twrp:
        description: 'ðŸ”„ Also Generate TWRP Device Tree'
        required: false
        type: boolean
        default: false
      upload_artifacts:
        description: 'â˜ï¸ Upload Artifacts to Release'
        required: false
        type: boolean
        default: true

env:
  PYTHON_VERSION: '3.11'
  WORKSPACE: ${{ github.workspace }}
  OUTPUT_DIR: ${{ github.workspace }}/output

jobs:
  extract-and-generate:
    name: ðŸ”§ Extract Firmware & Generate Device Tree
    runs-on: ubuntu-24.04
    timeout-minutes: 120
    
    steps:
      - name: ðŸ“¥ Checkout Repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: ðŸ Setup Python Environment
        uses: actions/setup-python@v5
        with:
          python-version: ${{ env.PYTHON_VERSION }}
          # NO CACHE - completely removed

      - name: ðŸ”§ Install System Dependencies
        run: |
          echo "::group::Installing system packages..."
          sudo apt-get update -qq
          sudo apt-get install -y -qq \
            unace unrar zip unzip p7zip-full p7zip-rar \
            sharutils rar uudeview mpack arj cabextract \
            rename liblzma-dev brotli lz4 \
            protobuf-compiler git gawk cpio \
            erofs-utils android-sdk-libsparse-utils \
            libxml2-utils bc curl wget aria2 \
            python3-dev build-essential file device-tree-compiler img2simg
          echo "::endgroup::"

      - name: ðŸ“¦ Install Python Tools
        run: |
          echo "::group::Installing Python packages..."
          pip install --upgrade pip setuptools wheel
          
          # Install dumpyara from git (latest version with all fixes)
          pip install git+https://github.com/sebastianmuetzel/dumpyara.git
          
          # Install aospdtgen
          pip install aospdtgen
          
          # Install twrpdtgen if needed
          if [[ "${{ inputs.generate_twrp }}" == "true" ]]; then
            pip install twrpdtgen
          fi
          
          # Install additional dependencies
          pip install \
            extract-dtb \
            pycryptodome \
            protobuf \
            backports.lzma \
            requests \
            tqdm \
            colorama \
            lz4 \
            zstandard \
            pyyaml \
            lxml
          echo "::endgroup::"
          
          # Verify installations
          echo "âœ… Python version: $(python3 --version)"
          which dumpyara || echo "dumpyara installed via pip"
          which aospdtgen || echo "aospdtgen installed via pip"

      - name: â¬‡ï¸ Download Firmware
        id: download
        run: |
          echo "::group::Downloading firmware..."
          mkdir -p ${{ env.OUTPUT_DIR }}
          DOWNLOAD_DIR="${{ env.WORKSPACE }}/downloads"
          mkdir -p "$DOWNLOAD_DIR"
          
          # Extract filename from URL
          FILENAME=$(basename "${{ inputs.rom_url }}" | cut -d'?' -f1 | cut -d'#' -f1)
          [[ -z "$FILENAME" ]] && FILENAME="firmware.zip"
          
          echo "ðŸ“¥ Downloading: $FILENAME"
          echo "ðŸ”— URL: ${{ inputs.rom_url }}"
          
          # Download with curl (fallback if aria2c not available)
          curl -L -o "$DOWNLOAD_DIR/$FILENAME" --progress-bar "${{ inputs.rom_url }}" || \
          wget -O "$DOWNLOAD_DIR/$FILENAME" --progress=bar:force "${{ inputs.rom_url }}"
          
          # Verify download
          if [[ ! -f "$DOWNLOAD_DIR/$FILENAME" ]]; then
            echo "âŒ Download failed!"
            exit 1
          fi
          
          FILE_SIZE=$(du -h "$DOWNLOAD_DIR/$FILENAME" | cut -f1)
          echo "âœ… Downloaded: $FILENAME ($FILE_SIZE)"
          echo "firmware_path=$DOWNLOAD_DIR/$FILENAME" >> $GITHUB_OUTPUT
          echo "firmware_name=$FILENAME" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: ðŸ” Analyze Firmware
        id: analysis
        run: |
          echo "::group::Analyzing firmware..."
          FIRMWARE_PATH="${{ steps.download.outputs.firmware_path }}"
          
          # Detect file type
          FILE_TYPE=$(file -b "$FIRMWARE_PATH")
          echo "ðŸ“‹ File type: $FILE_TYPE"
          
          # Check archive contents
          if [[ "$FIRMWARE_PATH" == *.zip ]]; then
            echo "ðŸ“¦ ZIP contents:"
            unzip -l "$FIRMWARE_PATH" | tail -20
            if unzip -l "$FIRMWARE_PATH" | grep -q "payload.bin"; then
              echo "rom_format=ab_ota" >> $GITHUB_OUTPUT
            elif unzip -l "$FIRMWARE_PATH" | grep -q "super.img"; then
              echo "rom_format=dynamic" >> $GITHUB_OUTPUT
            else
              echo "rom_format=standard" >> $GITHUB_OUTPUT
            fi
          else
            echo "rom_format=unknown" >> $GITHUB_OUTPUT
          fi
          echo "::endgroup::"

      - name: ðŸ—‚ï¸ Extract Firmware with Dumpyara
        id: dumpyara
        run: |
          echo "::group::Extracting firmware..."
          FIRMWARE_PATH="${{ steps.download.outputs.firmware_path }}"
          DUMP_DIR="${{ env.OUTPUT_DIR }}/dump"
          mkdir -p "$DUMP_DIR"
          
          echo "ðŸš€ Running dumpyara..."
          echo "   Input: $FIRMWARE_PATH"
          echo "   Output: $DUMP_DIR"
          
          # Run dumpyara
          dumpyara "$FIRMWARE_PATH" "$DUMP_DIR" 2>&1 | tee "${{ env.OUTPUT_DIR }}/dumpyara.log"
          
          # Find extracted directory
          EXTRACTED_DIR=$(find "$DUMP_DIR" -maxdepth 3 -type d -name "system" | head -1 | xargs dirname 2>/dev/null || \
                          find "$DUMP_DIR" -maxdepth 3 -type d -name "vendor" | head -1 | xargs dirname 2>/dev/null || \
                          echo "$DUMP_DIR")
          
          if [[ ! -d "$EXTRACTED_DIR" ]]; then
            echo "âŒ Extraction failed!"
            ls -laR "$DUMP_DIR"
            exit 1
          fi
          
          echo "ðŸ“ Extracted to: $EXTRACTED_DIR"
          ls -la "$EXTRACTED_DIR"
          
          # Get device info
          BUILD_PROP="$EXTRACTED_DIR/system/build.prop"
          [[ -f "$EXTRACTED_DIR/system/system/build.prop" ]] && BUILD_PROP="$EXTRACTED_DIR/system/system/build.prop"
          
          if [[ -f "$BUILD_PROP" ]]; then
            echo "ðŸ” Device info:"
            grep -E "ro.product.(device|brand|manufacturer|model)" "$BUILD_PROP" | head -5 || true
          fi
          
          echo "extracted_path=$EXTRACTED_DIR" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: ðŸŒ³ Generate AOSP Device Tree
        id: aospdtgen
        run: |
          echo "::group::Generating AOSP device tree..."
          EXTRACTED_PATH="${{ steps.dumpyara.outputs.extracted_path }}"
          DT_DIR="${{ env.OUTPUT_DIR }}/device-tree-aosp"
          mkdir -p "$DT_DIR"
          
          echo "ðŸŒ² Running aospdtgen..."
          echo "   Input: $EXTRACTED_PATH"
          echo "   Output: $DT_DIR"
          
          # Run aospdtgen
          aospdtgen -o "$DT_DIR" "$EXTRACTED_PATH" 2>&1 | tee "${{ env.OUTPUT_DIR }}/aospdtgen.log"
          
          # Check results
          if [[ ! -d "$DT_DIR" ]] || [[ -z "$(ls -A $DT_DIR 2>/dev/null)" ]]; then
            echo "âŒ AOSP DT generation produced no files!"
            exit 1
          fi
          
          FILE_COUNT=$(find "$DT_DIR" -type f | wc -l)
          echo "âœ… Generated $FILE_COUNT files"
          
          echo "ðŸ“ Contents:"
          find "$DT_DIR" -type f | head -20
          
          echo "aosp_dt_path=$DT_DIR" >> $GITHUB_OUTPUT
          echo "aosp_file_count=$FILE_COUNT" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: ðŸ”„ Generate TWRP Device Tree (Optional)
        if: inputs.generate_twrp == true
        id: twrpdtgen
        run: |
          echo "::group::Generating TWRP device tree..."
          EXTRACTED_PATH="${{ steps.dumpyara.outputs.extracted_path }}"
          TWRP_DIR="${{ env.OUTPUT_DIR }}/device-tree-twrp"
          mkdir -p "$TWRP_DIR"
          
          # Find recovery or boot image
          RECOVERY_IMG=$(find "$EXTRACTED_PATH" -maxdepth 3 -name "recovery.img" | head -1)
          BOOT_IMG=$(find "$EXTRACTED_PATH" -maxdepth 3 -name "boot.img" | head -1)
          
          TARGET_IMG="${RECOVERY_IMG:-$BOOT_IMG}"
          
          if [[ -z "$TARGET_IMG" ]]; then
            echo "âš ï¸ No recovery/boot image found"
            echo "twrp_status=skipped" >> $GITHUB_OUTPUT
            echo "::endgroup::"
            exit 0
          fi
          
          echo "ðŸ”„ Processing: $TARGET_IMG"
          
          # Run twrpdtgen
          twrpdtgen -o "$TWRP_DIR" "$TARGET_IMG" 2>&1 | tee "${{ env.OUTPUT_DIR }}/twrpdtgen.log" || true
          
          TWRP_COUNT=$(find "$TWRP_DIR" -type f 2>/dev/null | wc -l)
          echo "âœ… TWRP: $TWRP_COUNT files"
          
          echo "twrp_dt_path=$TWRP_DIR" >> $GITHUB_OUTPUT
          echo "twrp_status=completed" >> $GITHUB_OUTPUT
          echo "twrp_file_count=$TWRP_COUNT" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: ðŸ“¦ Package & Upload
        run: |
          echo "::group::Packaging..."
          cd ${{ env.OUTPUT_DIR }}
          
          # Create archives
          if [[ -d "device-tree-aosp" ]] && [[ "$(ls -A device-tree-aosp)" ]]; then
            tar -czf aosp-device-tree.tar.gz device-tree-aosp/
            echo "âœ… AOSP DT: $(du -h aosp-device-tree.tar.gz | cut -f1)"
          fi
          
          if [[ -d "device-tree-twrp" ]] && [[ "$(ls -A device-tree-twrp)" ]]; then
            tar -czf twrp-device-tree.tar.gz device-tree-twrp/
            echo "âœ… TWRP DT: $(du -h twrp-device-tree.tar.gz | cut -f1)"
          fi
          
          # Create report
          cat > GENERATION_REPORT.md << EOF
          # Device Tree Generation Report
          
          **ROM**: ${{ inputs.rom_url }}  
          **Date**: $(date -u +"%Y-%m-%d %H:%M:%S UTC")  
          
          ## Results
          - **AOSP Device Tree**: ${{ steps.aospdtgen.outputs.aosp_file_count }} files
          - **TWRP Device Tree**: ${{ steps.twrpdtgen.outputs.twrp_file_count }} files (status: ${{ steps.twrpdtgen.outputs.twrp_status }})
          EOF
          
          ls -lh *.tar.gz 2>/dev/null || echo "No archives"
          echo "::endgroup::"

      - name: â˜ï¸ Upload Artifacts
        uses: actions/upload-artifact@v4
        if: always()
        with:
          name: device-tree-${{ github.run_id }}
          path: |
            ${{ env.OUTPUT_DIR }}/*.tar.gz
            ${{ env.OUTPUT_DIR }}/*.md
            ${{ env.OUTPUT_DIR }}/*.log
          retention-days: 30
          if-no-files-found: warn

      - name: ðŸ“ Summary
        if: always()
        run: |
          echo "## ðŸ¤– Device Tree Generation" >> $GITHUB_STEP_SUMMARY
          echo "- **Download**: ${{ steps.download.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Extraction**: ${{ steps.dumpyara.outcome }}" >> $GITHUB_STEP_SUMMARY
          echo "- **AOSP DT**: ${{ steps.aospdtgen.outcome }} (${{ steps.aospdtgen.outputs.aosp_file_count }} files)" >> $GITHUB_STEP_SUMMARY
          [[ "${{ inputs.generate_twrp }}" == "true" ]] && echo "- **TWRP DT**: ${{ steps.twrpdtgen.outcome }}" >> $GITHUB_STEP_SUMMARY
